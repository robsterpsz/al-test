<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/service.js | altest</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="AL task made for testing purposes"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="altest"><meta property="twitter:description" content="AL task made for testing purposes"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/robsterpsz/al-test"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getApiTimeZone">getApiTimeZone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getMarketStatus">getMarketStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTimeToOpen">getTimeToOpen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toLocal">toLocal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toMoment">toMoment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get">get</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getRedisHash">getRedisHash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getRedisKeys">getRedisKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hgetallAsync">hgetallAsync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-scanAsync">scanAsync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-server">server</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-eventEmitter">eventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-redisClient">redisClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sc">sc</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/service.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import md5 from &apos;md5&apos;;
import { eventEmitter } from &apos;./index.js&apos;;
import { get } from &apos;./http.js&apos;;
import { getMarketStatus } from &apos;./dateUtils.js&apos;;
import { getRedisKeys, redisClient } from &apos;./redis.js&apos;;

/**
* sc object controls stock data flow
*/
export const sc = {
  addStockCacheKeys(stockId, key) {
    if (sc.stockCacheKeys &amp;&amp; sc.stockCacheKeys[stockId]) {
      sc.stockCacheKeys[stockId].push(key);
    } else {
      sc.stockCacheKeys[stockId] = [key];
    }
    return sc.lastStockCacheKey = key;
  },
  errorSimulation() {
    // La API debera simular un 10% rate de errores usando el siguiente codigo:
    if (Math.random(0, 1) &lt; 0.1) throw new Error(&apos;How unfortunate! The API Request Failed&apos;);
  },
  async getStockCacheKeys (stockId) {
    const keys = sc.stockCacheKeys &amp;&amp; sc.stockCacheKeys[stockId]
      &amp;&amp; sc.stockCacheKeys[stockId].length &gt; 0;
    let result = null;
    if (!keys) {
      const cacheKeys = await getRedisKeys(`stock:${stockId}:*`);
      sc.stockCacheKeys[stockId] = cacheKeys.sort();
      result = sc.stockCacheKeys[stockId];
    } else {
      result = sc.stockCacheKeys[stockId];
    }
    return result;
  },
  getStockPreCache (cacheSync) {
    return sc.preCache[cacheSync.stockId].filter((data) =&gt; {
      return parseInt(data[0], 10) &gt; cacheSync.lastUpdate;
    });
  },
  init: async () =&gt; {
    redisClient.hgetall(&apos;__STOCK_CONTROL__&apos;, (err, stocksData) =&gt; {
      if (err) throw new Error(&apos;Redis service error:&apos;, err);
      if (stocksData) {
        sc.dupeControl = stocksData.dupeControl;
        sc.lastUpdate = parseInt(stocksData.lastUpdate, 10);
        sc.stocks = JSON.parse(stocksData.stocks);
      }
    });
    const keys = await sc.getStockCacheKeys(&apos;*&apos;);
    keys.forEach((key) =&gt; {
      const stockId = key.split(&apos;:&apos;)[1];
      sc.preCache[stockId] = [];
    });
    return getStocksFromApi();
  },
  refreshStockInterval (time = 60 * 1000, fn = getStocksFromApi) {
    clearInterval(this.stockInterval);
    this.stockInterval = setInterval(fn, time);
    console.log(`Time to getStocksFromApi set to ${time/1000} secs`);
  },
  apiIsWorking: false,      // needed to set interval time to default (60 seconds) after sim error
  dupeControl: null,        // to avoid dupes on incoming data
  lastStockCacheKey: null,  // cheaper comparison param to perform feeding
  lastUpdate: null,         // used as comparer param and ref name in redis keys
  market: {},               // when market is closed client is not served at all
  preCache: {},             // used to save traffic quota on free redis cloud services
  stockCacheKeys: {},       // memoizing redis keys for each stock to emit cached data
  stockInterval: null,      // request stock data every 60 secs or 5 secs when retrying
  stocks: {}                // just the very last stock data, to be emitted as it arrives
};

/**
* getStocksFromApi requests stocks data, then saves and emits
* @param stockNames {Array} Contains a list of stock names
* @return true
*/
const getStocksFromApi = async (stockNames = [&apos;AAPL&apos;,&apos;ABC&apos;,&apos;MSFT&apos;,&apos;TSLA&apos;,&apos;F&apos;]) =&gt; {

  sc.market = getMarketStatus();

  if (!sc.market.isOpen &amp;&amp; sc.apiIsWorking) {

    sc.apiIsWorking = false;
    eventEmitter.emit(&apos;stock:close&apos;, sc.market);

    // this would work better on a &apos;non-stop&apos; enviroment: not suitable with heroku free dyno
    // const timeToOpen = getTimeToOpen();
    // refreshStockInterval(timeToOpen);
    // TODO: informar la usuario que no se va a actualizar mas hasta la proxima apertura.

  } else if (sc.market.isOpen &amp;&amp; !sc.apiIsWorking) {

    sc.apiIsWorking = true;
    sc.refreshStockInterval();

  }

  try {

    sc.errorSimulation();

    const url = `http://finance.google.com/finance/info?client=ig&amp;q=${stockNames.join(&apos;,&apos;)}`;
    const rawStocks = await get(url);

    // check if last response is different from current response
    // const lastStocks = JSON.stringify(rawStocks);
    const dupeControl = md5(JSON.stringify(rawStocks));

    if (sc.dupeControl !== dupeControl) {
      sc.dupeControl = dupeControl;

      // La data debera ser guardada en Redis,
      // usando Hashes para cada stock y el timestamp (unix) para cada transaccion guardada.

      let hasToBeArchived = false;
      const currentUpdate = new Date();
      if (sc.lastUpdate) {
        const lastUpdateDate = new Date(sc.lastUpdate * 1000);
        hasToBeArchived = lastUpdateDate.getDate() !== currentUpdate.getDate();
      }

      const unixTime = Math.floor(currentUpdate / 1000);
      const lastUpdate = unixTime.toString();

      rawStocks.forEach((stock) =&gt; {

        const redisKey = `stock:${stock.id}`;

        if (hasToBeArchived) {
          sc.preCache[stock.id] = [];
          const archiveKey = `stock:${stock.id}:${sc.lastUpdate}`;
          sc.addStockCacheKeys(stock.id, archiveKey);
          redisClient.rename(redisKey, archiveKey);
        }

        const stockValues = Object.keys(stock).map((key) =&gt; {
          const value = key === &apos;id&apos; ? lastUpdate : stock[key];
          return value;
        });

        redisClient.hset(redisKey, lastUpdate, JSON.stringify(stockValues));

        sc.stocks[stock.id] = [stockValues];

        if (sc.preCache &amp;&amp; sc.preCache[stock.id]) {
          sc.preCache[stock.id].push(stockValues);
        } else {
          sc.preCache[stock.id] = [stockValues];
        }

      });

      redisClient.hset(&apos;__STOCK_CONTROL__&apos;, [
        &apos;dupeControl&apos;, dupeControl,
        &apos;lastUpdate&apos;, lastUpdate,
        &apos;stocks&apos;, JSON.stringify(sc.stocks)
      ]);

      sc.lastUpdate = unixTime;

      // emit new data
      eventEmitter.emit(&apos;stock:add&apos;, {
        &apos;lastUpdate&apos;: unixTime,
        &apos;stocks&apos;: sc.stocks
      });
    }

    return true;

  } catch (ex) {

    // Se debera capturar SOLAMENTE este error para los reintentos
    // si existe otro error (ej: se cayo el api) debera manejarse de otra manera
    // (informandole al usuario la ultima actualizacion, que no existe conexion con el api, etc).

    if (/unfortunate/.test(ex)) {

      // this was needed for a border case: when retrying was beyond opening hours
      // and we still wanted to keep serving data
      sc.apiIsWorking = sc.market.isOpen ? false : true;
      const retryMs = 30;
      sc.refreshStockInterval(retryMs * 1000);

      eventEmitter.emit(&apos;stock:error&apos;, {
        active: true,
        message: `API request error simulation: retrying in ${retryMs} seconds.`,
        value: retryMs
      });

    } else {

      console.error(ex);
      eventEmitter.emit(&apos;stock:error&apos;, { message: &apos;API connection unavailable.&apos; });

    }
  }
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
